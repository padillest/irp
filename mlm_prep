# Importing libraries 

import pandas as pd 
import numpy as np 
from statistics import mean 

# Importing files for merge 

nu = pd.read_csv("C:/Users/denni/OneDrive/Desktop/NU v6.csv")
fu = pd.read_csv("C:/Users/denni/OneDrive/Desktop/FU v6.csv")

# Dropping unnecessary columns 

nu = nu.loc[:, ~nu.columns.str.contains("Updated")]
nu = nu.loc[:, ~nu.columns.str.contains("Answered")]
fu = fu.loc[:, ~fu.columns.str.contains("Updated")]
fu = fu.loc[:, ~fu.columns.str.contains("Answered")]

# Merging the new use and follow up datasets 

merge = pd.concat([nu, fu], ignore_index = True)

# Addressing the date format issues 

def date_combine(df, new_col, date_col, time_col):
    """ A function that combines two columns """ 
    df[new_col] = df[date_col] + " " + df[time_col]
    
date_combine(merge, "survey_start", "surveyStartDate", "surveyStartTime")
date_combine(merge, "survey_submit", "surveySubmitDate", "surveySubmitTime")
date_combine(merge, "trigger", "triggerDate", "triggerTime")

# Reformatting 

def date_conv(df, col):
    df[col] = pd.to_datetime(df[col], format = "%d/%m/%Y %I:%M:%S %p")
    
date_conv(merge, "survey_start")
date_conv(merge, "survey_submit")
date_conv(merge, "trigger")

# Dropping leftover columns 

col_drop = [
    "surveyStartDate", "surveyStartTime", "surveySubmitDate", 
    "surveySubmitTime", "triggerDate", "triggerTime"   
]

# Re-indexing 2500+ shape dataframe by ID and date

merge = merge.sort_values(by = ["id", "surveyStart"])
merge = merge.reset_index()
merge = merge.drop(columns = colDrop)

# Adding session numbers to new-use responses

merge["session"] = pd.Series(int)

n = 1 
data = pd.Index(merge)
for i in merge.index:
    # Storing current ID
    curr_ID = merge["id"].iloc[i]
    # Checking for end of list
    if i != data.size-1:
        # Storing the next ID 
        next_ID = merge["id"].iloc[i+1]
        if curr_ID == nextID:
            # Checking for survey type 
            survey_type = merge["surveyName"].iloc[i]
            if survey_type == "New Use Survey":
                merge.at[i, "session"] = n 
                n += 1
            else:
                merge.at[i, "session"] = n-1
        else:
            survey_type = merge["surveyName"].iloc[i]
            if survey_type == "New Use Survey":
                merge.at[i, "session"] = n 
                n = 1
            else:
                merge.at[i, "session"] = n-1
                n = 1
    else:
        survey_type = merge["surveyName"].iloc[i]
        if survey_type == "New Use Survey":
            merge.at[i, "session"] = n
        else:
            merge.at[i, "session"] = n-1
            
merge = merge.drop(columns = "index")

# Creating necessary compliance columns for compliance calculations

merge["compliance"] = pd.Series(int)
merge["person_compliance"] = pd.Series(int)
merge['person_total'] = pd.Series(int)
merge['person_completed'] = pd.Series(int)
merge['nu_total']=pd.Series(int)

# Dropping erroneous rows due to the software (MetricWire)

merge = merge.drop(index=[
    374, 402, 598, 599, 617, 702, 
    772, 913, 953, 1174, 1184, 1201, 
    1202, 1203, 1220, 1227, 1502, 1723,
    1820, 1969, 2330, 2338, 2364, 2387, 2388
])

merge = merge.reset_index(drop=True)

# Caluclating participant and survey compliance

session_compliance = []
total = []
complete =[]

data = pd.Index(merge)
n = 0
counter = 0 
nu_count = 0

def round_comp(i, session_compliance, total, complete, nu_count):
    merge.iloc[i, 104] = round((mean(session_compliance))*100, 2)
    merge.iloc[i,105] = sum(total)
    merge.iloc[i,106] = sum(complete)
    merge.iloc[i,107] = nu_count
    
def sess_comp_add(i, completed, total_FU):
    merge.iloc[i, 103] = completed/total_FU
    session_compliance.append(merge.iloc[i, 103])
    total.append(total_FU)
    complete.append(completed)

for i in merge.index: 
    # Storing current index ID 
    curr_ID = merge.iloc[i, 0]
    # Checking if at the end of the dataset 
    if i != data.size-1:
        # Storing the next ID
        next_ID = merge.iloc[i+1, 0]
        # Checking if we are within the same participant
        if curr_ID == nextID:
            # Storing the current session
            curr_sess = merge.iloc[i, 102]
            # Storing the next session
            next_sess = merge.iloc[i+1, 102]
            # Comparing if we are within the same session
            if curr_sess == next_sess:
                # Checking if the survey type is a New Use survey 
                if merge.iloc[i, 1] == "New Use Survey":
                    # Storing the submission time of the survey
                    submit_time = merge.iloc[i, 100]
                    # Creating denominator of total Follow-up surveys
                    total_FU = 2
                    # Initializing the completed number of survey variable 
                    completed = 0 
                    # Initializing the hour multiplier for calculating time submissions
                    n = 0 
                    counter = 0 
                    nu_count += 1
                    merge.iloc[i, 103] = np.nan
                    merge.iloc[i, 107] = np.nan
                else:
                    n += 1
                    # Calculating if the submission was submitted in time
                    survey_diff = (merge.iloc[i, 100] - submit_time).total_seconds()
                    # Checking if the submission time was within a two-hour window
                    if survey_diff <= (7200 * n):
                        completed += 1
                        if (merge.iloc[i, 2] == 1 or merge.iloc[i, 3] == 1):
                            total_FU += 1
                            if counter == 1:
                                total_FU += 1
                                counter = 0 
                        else:
                            counter += 1
            else:
                if merge.iloc[i, 1] == "New Use Survey":
                    total_FU = 2 
                    completed = 0 
                    nu_count +=1
                    merge.iloc[i, 107] = np.nan
                    sess_comp_add(i, completed, total_FU)
                else:
                    n += 1
                    survey_diff = (merge.iloc[i, 100] - submit_time).total_seconds()
                    if survey_diff > (7200 * n):
                        sess_comp_add(i, completed, total_FU)
                    else:
                        completed += 1
                        if (merge.iloc[i, 2] == 1 or merge.iloc[i, 3] == 1):
                            total_FU += 1 
                            if counter == 1:
                                total_FU += 1
                                sess_comp_add(i, completed, total_FU)
                            else:
                                sess_comp_add(i, completed, total_FU)
                        else:
                            sess_comp_add(i, completed, total_FU)                        
        else:
            if merge.iloc[i, 1] == "New Use Survey":
                total_FU = 2 
                completed = 0 
                n = 0
                nu_count+=1
                sess_comp_add(i, completed, total_FU)
                round_comp(i, session_compliance, total, complete, nu_Count)
                session_compliance = []
                total = []
                complete =[]
                nu_count=0
            else:
                n += 1 
                survey_diff = (merge.iloc[i, 100] - submit_time).total_seconds()
                if survey_diff > (7200 * n):
                        sess_comp_add(i, completed, total_FU)
                        round_comp(i, session_compliance, total, complete, nu_Count)
                        session_compliance = []
                        total = []
                        complete =[]
                        n = 0
                        nu_count=0
                else:
                    completed += 1
                    if (merge.iloc[i, 2] == 1 or merge.iloc[i, 3] == 1):
                        total_FU += 1 
                        n = 0
                        sess_comp_add(i, completed, total_FU)
                        round_comp(i, session_compliance, total, complete, nu_count)
                        session_compliance = []
                        total = []
                        complete =[]
                        nu_count=0
                    else:
                        n = 0
                        sess_comp_add(i, completed, total_FU)
                        round_comp(i, session_compliance, total, complete, nu_count)
                        session_compliance = []
                        total = []
                        complete =[]
                        nu_count=0
    else:
        if merge.iloc[i, 1] == "New Use Survey":
            total_FU = 2 
            completed = 0
            nu_count +=1
            sess_comp_add(i, completed, total_FU)
            round_comp(i, session_compliance, total, complete, nu_count)
        else:
            n += 1
            survey_diff = (merge.iloc[i, 100] - submit_time).total_seconds()
            if survey_diff > (7200 * n):
                sess_comp_add(i, completed, total_FU)
                round_comp(i, session_compliance, total, complete, nu_count)
            else:
                completed += 1
                if (merge.iloc[i, 2] == 1 or merge.iloc[i, 3] == 1):
                    total_FU += 1 
                    sess_comp_add(i, completed, total_FU)
                    round_comp(i, session_compliance, total, complete, nu_count)
                else:
                    sess_comp_add(i, completed, total_FU)
                    round_comp(i, session_compliance, total, complete, nu_count)
                    
# Saving as CSV to prepare it for multi-level modeling

merge.to_csv('C:/Users/denni/OneDrive/Desktop/mlm.csv')

## Reformatting to long data with hypothesized predictors ## 

data = pd.read_csv('C:/Users/denni/OneDrive/Desktop/mlm.csv')

# Filling in NAN values by reversing the index of the dataset # 

# Person Compliance #

pComp = data.loc[
    :,
    ['id', 'personCompliance']
]
bpComp = pComp.iloc[::-1]
for i in range(1, pd.Index(bpComp).size):
    if bpComp.iloc[i,0] == bpComp.iloc[i-1,0]:
        bpComp.iloc[i,1] = bpComp.iloc[i-1,1]
pCom = bpComp.iloc[::-1]
data['pComp']=pCom['personCompliance']

# Episode Compliance #

com = data.loc[
    :,
    ['session', 'compliance']
]
bCom = com.iloc[::-1]
bCom = bCom.reset_index(drop=True)
for i in bCom.index:
    if i==0:
        None
    else:
        if bCom.iloc[i,0]==bCom.iloc[i-1,0]:
            bCom.iloc[i,1]=bCom.iloc[i-1,1]
data['comp'] = comp['compliance']

## Identifying and storing columns of interest ## 

mlmVars = [
    'id','surveyName','pComp', 
    'comp','howHigh','howDrunk',
]
df = data.loc[
    :,
    mlmVars
]

## Calculating for poly-substance use episodes ## 

polySub = data.loc[
    :,
    [
        "id", "alcoholUse", "cannabisUse", "tobaccoUse", "otherUse"
    ]
]

polySub["polySub"] = [
    1 if x > 1 
    else 0 
    for x in np.sum(polySub.values == 1, 1)]

polySub["session"] = data["session"]

polySub["polySubEpisode"] = pd.Series(int)

x = pd.Index(polySub)
use = []

for i in polySub.index:
    currSess = polySub.iloc[i, 6]
    if i != x.size-1:
        nextSess = polySub.iloc[i+1,6]
        if currSess == nextSess:
            use.append(polySub.iloc[i, 5])
            polySub.iloc[i, 7] == np.nan
        else:
            use.append(polySub.iloc[i, 5])
            if 1 in use:
                polySub.iloc[i, 7] = 1
                use = []
            else:
                polySub.iloc[i, 7] = 0
                use = []
    else:
        use.append(polySub.iloc[i, 5])
        if 1 in use:
            polySub.iloc[i, 7] = 1
        else:
            polySub.iloc[i, 7] = 0
df['polySub'] = polySub.loc[
    :,
    'polySub'
]

# Dropping rows containing follow-up surveys # 

new_df = df[~df['surveyName'].str.contains('Follow Up Surveys')]
new_df.reset_index(drop=True)
new_df = new_df.replace('CONDITION_SKIPPED', 0)

# Changing data type of columns # 

new_df['pComp'] = new_df['pComp'].astype(float)
new_df['id'] = new_df['id'].astype(str)
new_df['howHigh'] = new_df['howHigh'].astype(int)
new_df['howDrunk'] = new_df['howDrunk'].astype(int)

## Calculating person means and within-person variance ## 

new_df=new_df.reset_index(drop=True)
new_df['howHigh_personMean'] = pd.Series(int)
new_df['howHigh_withinVar'] = pd.Series(int)

new_df['howDrunk_personMean'] = pd.Series(int)
new_df['howDrunk_withinVar'] = pd.Series(int)

new_df['polySub_personMean'] = pd.Series(int)
new_df['polySub_withinVar'] = pd.Series(int)

avgHigh = []
avgDrunk = []
avgPoly = []

def add(i):
    avgHigh.append(new_df.iloc[i,4])
    avgDrunk.append(new_df.iloc[i,5])
    avgPoly.append(new_df.iloc[i,6])
    
def empty(i):
    new_df.iloc[i,7]=np.nan
    new_df.iloc[i,9]=np.nan
    new_df.iloc[i,11]=np.nan
    
def average(i):
    new_df.iloc[i,7]=np.mean(avgHigh)
    new_df.iloc[i,9]=np.mean(avgDrunk)
    new_df.iloc[i,11]=np.mean(avgPoly)

for i in new_df.index:
    curr = new_df.iloc[i,0]
    if i != pd.Index(new_df).size-1:
        next = new_df.iloc[i+1,0]
        if curr==next:
            add(i)
            empty(i)
        else:
            add(i)
            average(i)
            avgHigh = []
            avgDrunk = [] 
            avgPoly = [] 
            
    else:
        add(i)
        average(i)

# Cleaning # 

data = data[~data['surveyName'].str.contains('Follow Up Surveys')]
data = data.reset_index(drop=True)

## Calculating limit analysis ## 

limitDrink = data.loc[
    :,
    [
        'id',
        'comp',
        'maxStandardDrink',
    ]
]

limitSmoke = data.loc[
    :,
    [
        'id',
        'comp',
        'maxCannabisGram'
    ]
]

limitDrink['maxStandardDrink'] = limitDrink['maxStandardDrink'].replace(
    {'CONDITION_SKIPPED':'1'}
)
limitDrink = limitDrink.reset_index(drop=True)
limitDrink = limitDrink.astype(float)

for i in limitDrink.index:
    if limitDrink.iloc[i,2]==99.0:
        limitDrink.iloc[i,2]=0.0
    else:
        limitDrink.iloc[i,2]=1.0
        

alcLimit = [] 

limitDrink['personMean'] = pd.Series(int)
limitDrink['withinVar'] = pd.Series(int)

def adding(i):
    alcLimit.append(limitDrink.iloc[i,2])
    
def empty(i):
    limitDrink.iloc[i,3]=np.nan

def avging(i):
    limitDrink.iloc[i,3]=np.mean(alcLimit)

# Drinking limit #

for i in limitDrink.index:
    curr = limitDrink.iloc[i,0]
    if i != pd.Index(limitDrink).size-1:
        next = limitDrink.iloc[i+1,0]
        if curr==next:
            adding(i)
            empty(i)
        else:
            adding(i)
            avging(i)
            alcLimit=[]
    else:
        adding(i)
        avging(i)

backDrink = limitDrink.iloc[::-1]
    
for i in range(1,pd.Index(backDrink).size):
    if backDrink.iloc[i,0]==backDrink.iloc[i-1,0]:
        backDrink.iloc[i,3]=backDrink.iloc[i-1,3]

limitDrink = backDrink.iloc[::-1]

def withinDrink(i):
    limitDrink.iloc[i,4]=limitDrink.iloc[i,2]-limitDrink.iloc[i,3]
    
for i in limitDrink.index:
    withinDrink(i)
    
limitDrink.to_csv('C:/Users/denni/OneDrive/Desktop/drinkLimit.csv')

# Smoking limit # 

limitSmoke['maxCannabisGram'] = limitSmoke['maxCannabisGram'].replace(
    {
    'CONDITION_SKIPPED':'4'
    }
)

limitSmoke = limitSmoke.reset_index(drop=True)
limitSmoke = limitSmoke.astype(float)

limitSmoke = limitSmoke[limitSmoke['maxCannabisGram']!=2]

limitSmoke = limitSmoke.reset_index(drop=True)

limitSmoke['maxCannabisGram'] = limitSmoke['maxCannabisGram'].replace({1.0:0.0})

for i in limitSmoke.index:
    if limitSmoke.iloc[i,2] != 0.0:
        limitSmoke.iloc[i,2] = 1


canLimit = [] 

limitSmoke['personAvg'] = pd.Series(int)
limitSmoke['withinVar'] = pd.Series(int)

def canAdd(i):
    canLimit.append(limitSmoke.iloc[i,2])

def canEmpty(i):
    limitSmoke.iloc[i,3]=np.nan
    
def canAvg(i):
    limitSmoke.iloc[i,3]=np.mean(canLimit)
    
for i in limitSmoke.index:
    curr = limitSmoke.iloc[i,0]
    if i != pd.Index(limitSmoke).size-1:
        next = limitSmoke.iloc[i+1,0]
        if curr == next:
            canAdd(i)
            canEmpty(i)
        else:
            canAdd(i)
            canAvg(i)
            canLimit=[]
    else:
        canAdd(i)
        canAvg(i)

backSmoke = limitSmoke.iloc[::-1]


for i in range(1,pd.Index(backSmoke).size):
    if backSmoke.iloc[i,0]==backSmoke.iloc[i-1,0]:
        backSmoke.iloc[i,3]=backSmoke.iloc[i-1,3]

limitSmoke = backSmoke.iloc[::-1]

def withinSmoke(i):
    limitSmoke.iloc[i,4]=limitSmoke.iloc[i,2]-limitSmoke.iloc[i,3]
    
for i in limitSmoke.index:
    withinSmoke(i)

limitSmoke.to_csv('C:/Users/denni/OneDrive/Desktop/smokeLimit.csv')

## Calculating maximum drinks/cannabis per session ## 

maxDrink = data.loc[
    :,
    [
        'id',
        'comp',
        'maxStandardDrink',
    ]
]

maxSmoke = data.loc[
    :,
    [
        'id',
        'comp',
        'maxCannabisGram'
    ]
]

# Maximum drinks # 

maxDrink = maxDrink[~maxDrink.maxStandardDrink.str.contains('99')]
maxDrink['maxStandardDrink'] = maxDrink['maxStandardDrink'].replace(
{
    'CONDITION_SKIPPED':'0'
})

maxDrink.maxStandardDrink = maxDrink.maxStandardDrink.astype(float)

maxDrink = maxDrink.reset_index(drop=True)

maxPlanDrink = [] 

maxDrink['personAvg'] = pd.Series(int)
maxDrink['withinVar'] = pd.Series(int)

def addPlanDrink(i):
    maxPlanDrink.append(maxDrink.iloc[i,2])
    
def makeNull(i):
    maxDrink.iloc[i,3] = np.nan
    
def planDrinkAvg(i):
    maxDrink.iloc[i,3]=np.mean(maxPlanDrink)
    
for i in maxDrink.index:
    curr=maxDrink.iloc[i,0]
    if i != pd.Index(maxDrink).size-1:
        fut=maxDrink.iloc[i+1,0]
        if curr==fut:
            addPlanDrink(i)
            makeNull(i)
        else:
            addPlanDrink(i)
            planDrinkAvg(i)
            maxPlanDrink=[]
    else:
        addPlanDrink(i)
        planDrinkAvg(i)

backMaxDrink = maxDrink.iloc[::-1]
for i in range(1,pd.Index(backMaxDrink).size):
    if backMaxDrink.iloc[i,0]==backMaxDrink.iloc[i-1,0]:
        backMaxDrink.iloc[i,3]=backMaxDrink.iloc[i-1,3]

maxDrink = backMaxDrink.iloc[::-1]

def withinVar(i):
    maxDrink.iloc[i,4]=maxDrink.iloc[i,2]-maxDrink.iloc[i,3]
    
for i in maxDrink.index:
    withinVar(i)
    
maxDrink.to_csv('C:/Users/denni/OneDrive/Desktop/maxPlannedDrink.csv')

# Maximum cannabis # 

maxSmoke['maxCannabisGram'] = maxSmoke['maxCannabisGram'].replace(
{
    'CONDITION_SKIPPED':'0'
})
maxSmoke = maxSmoke[~maxSmoke.maxCannabisGram.str.contains('2')]
maxSmoke = maxSmoke[~maxSmoke.maxCannabisGram.str.contains('1')]

ordGram = {
    3:0.062,
    4:0.125,
    5:0.25,
    6:0.5,
    7:0.75,
    8:1,
    9:1.25
}

maxSmoke = maxSmoke.astype(float)

maxSmoke.maxCannabisGram = maxSmoke.maxCannabisGram.replace(ordGram)
maxSmoke = maxSmoke.reset_index(drop=True)

maxSmoke['personAvg'] = pd.Series(int)
maxSmoke['withinVar'] = pd.Series(int)

maxPlanSmoke = [] 

def addSmoke(i):
    maxPlanSmoke.append(maxSmoke.iloc[i,2])
    
def createNull(i):
    maxSmoke.iloc[i,3]=np.nan

def createAvg(i):
    maxSmoke.iloc[i,3]=np.mean(maxPlanSmoke)

for i in maxSmoke.index:
    curr=maxSmoke.iloc[i,0]
    if i != pd.Index(maxSmoke).size-1:
        fut=maxSmoke.iloc[i+1,0]
        if curr==fut:
            addSmoke(i)
            createNull(i)
        else:
            addSmoke(i)
            createAvg(i)
            maxPlanSmoke=[]
    else:
        addSmoke(i)
        createAvg(i)
        
backMaxSmoke = maxSmoke.iloc[::-1]

for i in range(1,pd.Index(backMaxSmoke).size):
    if backMaxSmoke.iloc[i,0]==backMaxSmoke.iloc[i-1,0]:
        backMaxSmoke.iloc[i,3]=backMaxSmoke.iloc[i-1,3]

maxSmoke = backMaxSmoke.iloc[::-1]

def withinVar(i):
    maxSmoke.iloc[i,4]=maxSmoke.iloc[i,2]-maxSmoke.iloc[i,3]
    
for i in maxSmoke.index:
    withinVar(i)
    
maxSmoke.to_csv('C:/Users/denni/OneDrive/Desktop/maxPlannedSmoke.csv')
